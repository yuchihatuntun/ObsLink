/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZenMode
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var ZenMode = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.hasButton = false;
    this._isTogglingZen = false;
    this.visualViewportResizeHandler = null;
    // refresh function for when we change settings
    this.refresh = () => {
      this.updateStyle();
      this.setSidebarVisibility();
      this.setButtonVisibility();
      this.updateFocusedFileMode();
    };
    // update the styles (at the start, or as the result of a settings change)
    this.updateStyle = () => {
      document.body.classList.toggle("zenmode-active", this.settings.zenMode);
      document.documentElement.style.setProperty(
        "--zen-mode-top-padding",
        `${this.settings.topPadding}px`
      );
      document.documentElement.style.setProperty(
        "--zen-mode-bottom-padding",
        `${this.settings.bottomPadding}px`
      );
      if (this.settings.zenMode) {
        document.body.classList.toggle(
          "zenmode-hide-properties",
          this.settings.hideProperties
        );
      } else {
        document.body.classList.remove("zenmode-hide-properties");
      }
      if (this.settings.zenMode) {
        document.body.setAttribute(
          "data-zen-hide-inline-title",
          this.settings.hideInlineTitle.toString()
        );
        document.body.setAttribute(
          "data-zen-focused-file",
          this.settings.focusedFileMode.toString()
        );
      } else {
        document.body.removeAttribute("data-zen-hide-inline-title");
        document.body.removeAttribute("data-zen-focused-file");
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new ZenModeSettingTab(this.app, this));
    this.addCommand({
      id: "toggle-zen-mode",
      name: "Toggle",
      callback: () => {
        this.toggleZenMode();
      }
    });
    this.addRibbonIcon("expand", "Toggle Zen mode", async () => {
      this.toggleZenMode();
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.updateFocusedFileMode();
      })
    );
    this.refresh();
  }
  onunload() {
    if (this.buttonContainer) {
      this.buttonContainer.remove();
    }
    if (this.visualViewportResizeHandler && window.visualViewport) {
      window.visualViewport.removeEventListener(
        "resize",
        this.visualViewportResizeHandler
      );
    }
  }
  async loadSettings() {
    this.settings = Object.assign(DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  setSidebarVisibility() {
    const app = this.app;
    if (app.workspace.leftSplit == void 0 || app.workspace.rightSplit == void 0) {
      return;
    }
    if (!this.settings.zenMode) {
      if (!this.settings.leftSidebar) {
        app.workspace.leftSplit.expand();
      }
      if (!this.settings.rightSidebar) {
        app.workspace.rightSplit.expand();
      }
    } else {
      this.settings.rightSidebar = this.app.workspace.rightSplit.collapsed;
      this.settings.leftSidebar = this.app.workspace.leftSplit.collapsed;
      if (app.workspace.leftSplit.collapsed != this.settings.zenMode) {
        app.workspace.leftSplit.collapse();
      }
      if (app.workspace.rightSplit.collapsed != this.settings.zenMode) {
        app.workspace.rightSplit.collapse();
      }
    }
  }
  createButton() {
    this.buttonContainer = document.createElement("div");
    this.buttonContainer.classList.add("zenmode-button");
    this.button = new import_obsidian.ButtonComponent(this.buttonContainer);
    this.button.setIcon("shrink");
    this.button.onClick(() => {
      this.toggleZenMode();
    });
    document.body.appendChild(this.buttonContainer);
    this.adjustButtonPosition();
    this.registerDomEvent(window, "resize", () => {
      this.adjustButtonPosition();
    });
    if (window.visualViewport) {
      this.visualViewportResizeHandler = () => {
        this.adjustButtonPosition();
      };
      window.visualViewport.addEventListener(
        "resize",
        this.visualViewportResizeHandler
      );
    }
  }
  adjustButtonPosition() {
    var _a;
    if (!this.buttonContainer || !document.body.classList.contains("is-mobile")) {
      return;
    }
    const viewportHeight = ((_a = window.visualViewport) == null ? void 0 : _a.height) || window.innerHeight;
    const windowHeight = window.outerHeight;
    const navigationBarHeight = Math.max(0, windowHeight - viewportHeight);
    const minBottomOffset = 60;
    const calculatedOffset = Math.max(
      minBottomOffset,
      navigationBarHeight + 10
    );
    this.buttonContainer.style.bottom = `${calculatedOffset}px`;
  }
  setButtonVisibility() {
    const shouldShow = this.settings.zenMode && (this.settings.exitButtonVisibility === "always" || this.settings.exitButtonVisibility === "mobile-only" && document.body.classList.contains("is-mobile"));
    if (shouldShow) {
      if (!this.hasButton) {
        this.createButton();
        this.hasButton = true;
      }
      this.buttonContainer.style.display = "block";
      this.adjustButtonPosition();
    } else {
      if (this.hasButton) {
        this.buttonContainer.style.display = "none";
      }
    }
  }
  // Update focused file mode visibility
  updateFocusedFileMode() {
    if (!this.settings.zenMode || !this.settings.focusedFileMode) {
      const allTabContainers2 = document.querySelectorAll(".workspace-tabs");
      allTabContainers2.forEach((container) => {
        const el = container;
        el.style.display = "";
        el.style.width = "";
        el.style.flex = "";
      });
      return;
    }
    const activeLeaf = this.app.workspace.activeLeaf;
    if (!activeLeaf) return;
    const activeLeafContainer = activeLeaf && "containerEl" in activeLeaf ? activeLeaf.containerEl : null;
    if (!activeLeafContainer) return;
    const activeTabContainer = activeLeafContainer.closest(".workspace-tabs");
    if (!activeTabContainer) return;
    const allTabContainers = document.querySelectorAll(".workspace-tabs");
    allTabContainers.forEach((tabContainer) => {
      if (tabContainer === activeTabContainer) {
        tabContainer.style.display = "";
        tabContainer.style.width = "100%";
        tabContainer.style.flex = "1 1 100%";
      } else {
        tabContainer.style.display = "none";
      }
    });
  }
  async toggleZenMode() {
    if (this._isTogglingZen) {
      return;
    }
    this._isTogglingZen = true;
    try {
      const enteringZenMode = !this.settings.zenMode;
      if (enteringZenMode) {
        if (this.settings.fullscreen && document.documentElement.requestFullscreen) {
          try {
            await document.documentElement.requestFullscreen();
            await new Promise(
              (resolve) => requestAnimationFrame(resolve)
            );
          } catch (e) {
            console.warn("Failed to enter fullscreen:", e);
          }
        }
        this.settings.zenMode = true;
        await this.saveSettings();
        this.refresh();
      } else {
        if (document.fullscreenElement && document.exitFullscreen) {
          try {
            await document.exitFullscreen();
            await new Promise(
              (resolve) => requestAnimationFrame(resolve)
            );
          } catch (e) {
            console.warn("Failed to exit fullscreen:", e);
          }
        }
        this.settings.zenMode = false;
        await this.saveSettings();
        this.refresh();
      }
    } finally {
      this._isTogglingZen = false;
    }
  }
};
var DEFAULT_SETTINGS = {
  zenMode: false,
  leftSidebar: false,
  rightSidebar: false,
  fullscreen: false,
  exitButtonVisibility: "mobile-only",
  hideProperties: false,
  hideInlineTitle: false,
  topPadding: 0,
  bottomPadding: 0,
  focusedFileMode: false
};
var ZenModeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Preview Zen mode").setDesc("Preview Zen mode (use a hotkey to toggle)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.zenMode).onChange((value) => {
        this.plugin.settings.zenMode = value;
        this.plugin.saveSettings();
        this.plugin.refresh();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Full screen").setDesc("Automatically enter fullscreen when enabling Zen mode").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.fullscreen).onChange((value) => {
        this.plugin.settings.fullscreen = value;
        this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Zen mode exit button").setDesc("When to show the exit button in Zen mode").addDropdown(
      (dropdown) => dropdown.addOption("mobile-only", "Mobile Only").addOption("always", "Always Show").addOption("never", "Never Show").setValue(this.plugin.settings.exitButtonVisibility).onChange((value) => {
        this.plugin.settings.exitButtonVisibility = value;
        this.plugin.saveSettings();
        this.plugin.refresh();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Hide properties in Zen mode").setDesc(
      "Hide properties (YAML frontmatter) when Zen mode is active"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.hideProperties).onChange((value) => {
        this.plugin.settings.hideProperties = value;
        this.plugin.saveSettings();
        this.plugin.refresh();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Hide inline title in Zen mode").setDesc(
      "Hide the inline title (note title) when Zen mode is active"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.hideInlineTitle).onChange((value) => {
        this.plugin.settings.hideInlineTitle = value;
        this.plugin.saveSettings();
        this.plugin.refresh();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Top padding").setDesc("Top padding in pixels (0-100)").addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.topPadding).setDynamicTooltip().onChange((value) => {
        this.plugin.settings.topPadding = value;
        this.plugin.saveSettings();
        this.plugin.refresh();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Bottom padding").setDesc("Bottom padding in pixels (0-100)").addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.bottomPadding).setDynamicTooltip().onChange((value) => {
        this.plugin.settings.bottomPadding = value;
        this.plugin.saveSettings();
        this.plugin.refresh();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Focused file mode").setDesc(
      "Only show the active file in Zen mode, hide all other panes"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.focusedFileMode).onChange((value) => {
        this.plugin.settings.focusedFileMode = value;
        this.plugin.saveSettings();
        this.plugin.refresh();
      })
    );
  }
};
