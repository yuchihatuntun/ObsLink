---
title: MCP-Chapter-03
date: 2025-12-23
description: Studying Several Common Interface Chips with Richer Functions and Stronger Performance
tags:
  - 2025-autumn
  - MCP
  - Notebook
image: "[[attachments/cover-033.png]]"
imageAlt:
imageOG: true
hideCoverImage: false
hideTOC: false
targetKeyword: ""
draft: true
---
# 8086 寻址方式

## 存储器体系结构

不管实际存储容量是多少，CPU 都默认自己有无限大的存储空间（即理想存储情况）。

```mermaid
graph LR
    A[寄存器] --> B[Cache]
    B --> C[主存]
    C --> D[辅存]
```
### 局部性原理

1. **时间局部性**：刚用过的数据，很可能马上还要再用一次。

2. **空间局部性**：刚用过的数据，它旁边的数据，很可能马上也要被用。

**工作流程：**
```mermaid
graph LR
    A[CPU 需要数据] --> B[访问Cache查询]
    
    B -- 有数据 --> C{Cache结果}
    C -- 命中 Hit --> D[CPU 立即从Cache获取数据<br>皆大欢喜，速度很快]
    
    B -- 无数据 --> E{Cache结果}
    E -- 未命中 Miss --> F[CPU 停工等待]
    F --> G[Cache 向主存请求数据]
    G --> H[主存返回数据<br>（包含所需数据及其邻近小块）]
    H --> I[Cache 保存数据并传给CPU]
    I --> J[CPU 继续工作]
```


## 寻址方式

### 概述

| 寻址方式    | 操作数位置  | 说明                  |
| :------ | :----- | :------------------ |
| 立即寻址    | 在指令代码中 | 操作数作为指令的一部分直接给出     |
| 寄存器寻址   | 在寄存器中  | 操作数在寄存器内            |
| 存储器寻址   | 在主存中   | 操作数在内存单元里，指令中会给出其地址 |
| I/O端口寻址 | 在IO端口中 | 操作数在外设的端口内          |
>**注意：** 寻址方式是针对==操作数==而言的。即寻找对应表述地址里面的==数据==（不管是立即数，还是从寄存器、主存里找到对应的数据）。


### 立即寻址

操作数（数据）作为指令机器码的一部分，存放在内存的==代码段==中。

>[!note] 案例分析
>
>1. **`MOV AX 1234H`**：其中的`1234H`即为立即数，此种寻址方式即为立即寻址。
>

>立即数只能作为==源操作数==，只能传给==存储器和通用寄存器==，不能直接给段寄存器。
### 寄存器寻址

用寄存器代号代替对应寄存器内部放置的数据。

>[!note] 案例分析
>
>1. **`MOV AX BX`**：把`BX`里面的数据给到`AX`里面，用寄存器代号`BX`来代替里面的数据。

> 源寄存器和目的寄存器的类型要一样，
### 存储器寻址

8086 的物理地址为：`段地址 + 偏移地址`

其中：`偏移地址 = 有效地址 = 基址（BX BP） + 变址(SI DI) + 位移量`

段地址基本上不会直接出现在指令代码中，会根据偏移地址中使用的寄存器==默认匹配==段。

#### 直接（位移量）寻址

如`MOV AL,[2000H]`，这里不需要PTR。实际使用过程中经常使用`MOV AL,DATA1`也就是变量来直接寻址。

> ==存储单元之间不能互相直接操作数据==。如果将data2处数据放到data1，需要AL这种通用寄存器来过渡。

#### 寄存器间接寻址

只能用`BX,SI,DI`，如`[BX]`，具体语句：

```asm
MOV BX, OFFSET DATA1
MOV AL,[BX]
```





